## 곳감 (모래시계)

### 내 풀이 (이 문제는 내 풀이 보다 밑에 강의 풀이를 보도록 하자...)

##### 초기 변수

````python
N = int(sys.stdin.readline())
a = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]
M = int(sys.stdin.readline())
#input
5
10 13 10 12 15
12 39 30 23 11
11 25 50 53 15
19 27 29 37 27
19 13 30 13 19
3
#나머지 인풋은 for문에 넣었다.
#output
362
````

##### 리스트 회전

* 문제에 주어진 회전명령 정보 만큼 for문을 시작한다.

`````python
for i in range(M) :
    b = list(map(int, sys.stdin.readline().split()))
  	```
    #input
    #b[0] = 행번호
    #b[1] = 0좌 1우 회전
    #b[2] = 회전하는 횟수
  	[2 0 3]
    [5 1 2]
    [3 1 4]
  	```
    arr = [0] * N #빈 배열 생성
`````

* **오른쪽으로 회전**

  * b[1] = 1 이면 오른쪽으로 회전한다.

  * ex ) **N = 5** , **p1 = 3 (b[2]), p2 = 0 ** 일 때

  * 주어진 리스트

  * | 0    | 1    | 2    | 3    | 4    |
    | ---- | ---- | ---- | ---- | ---- |
    | 12   | 39   | 30   | 23   | 11   |

  * arr 리스트  p1번 째 인덱스에 `a[b[0] -1][j]` 값을 할당하고 P1에 1을 더한다.

    |      |      |      | p1 (3) | p1 (4) |
    | ---- | ---- | ---- | ------ | ------ |
    | 0    | 1    | 2    | 3      | 4      |
    | 0    | 0    | 0    | 12     | 39     |

  * p1이 N 보다 크거나 같아질 경우 p2를 이용해서 나머지 arr 리스트도 채워준다

  * | p2 (0) | p2 (1) | p2 (2) | p1 (3) | p1 (4) |
    | ------ | ------ | ------ | ------ | ------ |
    | 0      | 1      | 2      | 3      | 4      |
    | 30     | 23     | 11     | 12     | 39     |

  * `a[b[0] - 1]` 해당하는 리스트에 arr를 삽입해준다.

```python
#오른쪽 회전    
if b[1] == 1 :
    p1 = b[2] # 오른쪽 index 증가
    p2 = 0 # 왼쪽 index 증가
    
    while N < p2 : # p2가 N 보다 크면 N 만큼 계속 뺴준다.
        p2 = p2 - N
        
    for j in range(N) :
        if N - p1 > 0 :
            arr[p1] = a[b[0] -1][j]
            p1 += 1
        else :
            arr[p2] = a[b[0] -1][j]
            p2 += 1

    a[b[0] - 1] = arr #해당하는 리스트에 arr를 삽입해준다.
```

* **왼쪽으로 회전**

  * b[1] = 0 이면 왼쪽으로 회전한다.

  * ex ) **N = 5** , **p2 = 3 (b[2]), p1 = 0 ** 일 때

  * 주어진 리스트

  * | 0    | 1    | 2    | 3    | 4    |
    | ---- | ---- | ---- | ---- | ---- |
    | 12   | 39   | 30   | 23   | 11   |

  * **for문을 거꾸로 시작했다** 

    * ```python
       for j in range(N-1, -1, -1) : # 4,3,2,1,0 [11,23,30,39,12]
      ```

  * arr 리스트  [N - p2 -1] 

    * ```python
      5 -3 -1 # 1번 인덱스에 11 삽입
      p2 += 1
      5 -4 -1 # 0번 인덱스에 23 삽입
      ```

  * | p2(4) | p2(3) |      |      |      |
    | ----- | ----- | ---- | ---- | ---- |
    | 0     | 1     | 2    | 3    | 4    |
    | 23    | 11    | 0    | 0    | 0    |

  * p2가 N보다 크거나 같아질 경우 P1을 이용한다

    * ```
      5 -0 -1 # 4번 인덱스에 30 삽입
      p2 += 1
      5 -1 -1 # 3번 인덱스에 39 삽입
      ```

    * 

  * | p2(4) | p2(3) | p1(2) | p1(1) | p1(0) |
    | ----- | ----- | ----- | ----- | ----- |
    | 0     | 1     | 2     | 3     | 4     |
    | 23    | 11    | 30    | 39    | 12    |

```python
#왼쪽 회전
else :
    p2 = b[2] # 왼쪽 index 증가
    p1 = 0   # 오른쪽 index 증가

    while N < p2 : # p2가 N 보다 크면 N 만큼 계속 뺴준다.
        p2 = p2 - N

    for j in range(N-1, -1, -1) : # 4,3,2,1,0
        if N - p2 > 0 :
            print(a[b[0]-1])
            print(arr)
            arr[N - p2 -1] = a[b[0] -1][j]
            p2 += 1
        else :
            arr[N - p1 -1] = a[b[0] -1][j] 
            p1 += 1
    a[b[0] - 1] = arr
```



##### 합 구하기

* p1은 왼쪽부터 시작
* p2는 오른쪽부터 시작
* **이중 for문**을 사용해서 **p1 ~ p2까지의 간격** 사이 합을 num 변수에 저장한다.
* **i 가 center 보다 커지면** 중간값을 포함하여 리스트 밑을 탐색한다. 

````python
<10 13 10 12 15>
12 <39 30 23> 11
11 25 <50> 53 15
19 <27 29 37> 27
<19 13 30 13 19>

# 모래시계 모양 합 구하기
center = N // 2 #2 중간 값 0,1,(2),3,4
p1 = 0 #왼쪽부터 시작
p2 = N #오른쪽부터 시작
num = 0 #값 저장
for i in range(N) :
    if i < center : #0,1,2 < 3
        for j in range(p1, p2) :
            num += a[i][j]
        p1 += 1
        p2 -= 1 
    else : 
        for j in range(p1, p2) : #중간 값부터 시작
            num += a[i][j]
        p1 -= 1
        p2 += 1
print(num)
````



### 강의 풀이

#####  pop을 이용해서 회전

* 왼쪽으로 회전

```python
#제일 앞에 있는 값을 빼 내서 리스트 맨 뒤로 저장
#ex) 
a = [1,2,3,4,5]
a = a.pop(0) # [2,3,4,5,1]
# 빠진 수 자리를 다음 수가 index 0으로 채움
```

* 오른쪽으로 회전

```python
#제일 뒤에 있는 값을 빼 내서 리스트 맨 앞으로 저장
#ex)
a = [1,2,3,4,5]
#pop() 빈 값으로 하면 맨 뒤에 값을 꺼낸다.
a = a.insert(0, a.pop()) # [5,1,2,3,4]
```

* **for문을 사용해서 k번 만큼 회전한다.**

```python
# 회전 하기
for i in range(M) :
    h, t, k = map(int, input().split())
    #왼쪽으로 회전
    if t == 0 :
        for _ in range(k) :
            #제일 앞에 있는 값을 빼 내서 리스트 맨 뒤로 저장
            # 빠진 수 자리를 다음 수가 index 0으로 채움
            a[h - 1].append(a[h - 1].pop(0))

    # 오른쪽으로 회전
    else :
        for _ in range(k) :
            a[h - 1].insert(0, a[h - 1].pop()) #제일 뒤에 있는 값을 빼 내서 리스트 맨 앞으로 저장
```



##### 합 구하기

* 내 풀이와 비슷하지만 **for문을 먼저 사용**하고 **그 뒤에 if문**을 사용했다.

```
p1 = 0
p2 = N - 1
num = 0
for i in range(N) :
        for j in range(p1, p2 + 1) :
            num += a[i][j]
        if i < N // 2 :
            p1 += 1
            p2 -= 1
        else :
            p1 -= 1
            p2 += 1
print(num)
```



### 후기

* 다 풀고 나서 굉장히 뿌듯했는데 **pop()** 사용하는 걸 알았다면 더 효과적으로 풀 수 있었을 것 같다 ㅎ...
* pop 사용 없이 풀었더니 굉장히 비효율적인 알고리즘이 된 것 같다 ㅠ